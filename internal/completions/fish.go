package completions

import (
	"fmt"
	"strings"
)

// GenerateFish generates a fish completion script
func GenerateFish(commands []CommandInfo) string {
	bin := GetBinaryName()

	var b strings.Builder

	fmt.Fprintf(&b, `# %s fish completion script
# Generated by %s completions

# Disable file completions for %s
complete -c %s -f

# Global flags
complete -c %s -s h -l help -d 'Show help'
complete -c %s -s v -l version -d 'Show version'
complete -c %s -l no-color -d 'Disable colored output'
complete -c %s -l no-pager -d 'Do not use pager'
complete -c %s -l pager -d 'Use specified pager' -r

`, bin, bin, bin, bin, bin, bin, bin, bin, bin)

	// Find root command to get top-level subcommands
	var rootSubcmds []string
	for _, cmd := range commands {
		if len(cmd.Path) == 1 {
			rootSubcmds = cmd.Subcommands
			break
		}
	}

	// Generate completions for top-level commands
	b.WriteString("# Top-level commands\n")
	for _, subcmdName := range rootSubcmds {
		// Find the command to get its summary
		for _, cmd := range commands {
			if len(cmd.Path) == 2 && cmd.Name == subcmdName {
				desc := escapeForFish(cmd.Summary)
				fmt.Fprintf(&b, "complete -c %s -n '__fish_use_subcommand' -a %s -d '%s'\n", bin, subcmdName, desc)
				break
			}
		}
	}

	b.WriteString("\n")

	// Generate completions for subcommands
	for _, cmd := range commands {
		if len(cmd.Path) != 2 {
			continue
		}

		cmdName := cmd.Name

		// Add subcommands
		if len(cmd.Subcommands) > 0 {
			fmt.Fprintf(&b, "# %s subcommands\n", cmdName)
			for _, subcmdName := range cmd.Subcommands {
				// Find subcommand summary
				subcmdPath := append(append([]string{}, cmd.Path...), subcmdName)
				if subcmd := FindCommand(commands, subcmdPath); subcmd != nil {
					desc := escapeForFish(subcmd.Summary)
					fmt.Fprintf(&b, "complete -c %s -n '__fish_seen_subcommand_from %s; and not __fish_seen_subcommand_from %s' -a %s -d '%s'\n",
						bin, cmdName, strings.Join(cmd.Subcommands, " "), subcmdName, desc)
				}
			}
		}

		// Add flags for the command
		if len(cmd.Flags) > 0 {
			fmt.Fprintf(&b, "# %s flags\n", cmdName)
			for _, f := range cmd.Flags {
				writeFishFlag(&b, bin, cmdName, f)
			}
		}

		if len(cmd.Subcommands) > 0 || len(cmd.Flags) > 0 {
			b.WriteString("\n")
		}
	}

	return b.String()
}

func writeFishFlag(b *strings.Builder, bin, cmdName string, f FlagInfo) {
	if len(f.Names) == 0 {
		return
	}

	desc := escapeForFish(f.Description)

	var short, long string
	for _, name := range f.Names {
		if strings.HasPrefix(name, "--") {
			long = strings.TrimPrefix(name, "--")
		} else if strings.HasPrefix(name, "-") {
			short = strings.TrimPrefix(name, "-")
		}
	}

	parts := []string{fmt.Sprintf("complete -c %s", bin)}
	parts = append(parts, fmt.Sprintf("-n '__fish_seen_subcommand_from %s'", cmdName))

	if short != "" {
		parts = append(parts, fmt.Sprintf("-s %s", short))
	}
	if long != "" {
		parts = append(parts, fmt.Sprintf("-l %s", long))
	}
	if f.HasValue {
		parts = append(parts, "-r")
	}
	parts = append(parts, fmt.Sprintf("-d '%s'", desc))

	b.WriteString(strings.Join(parts, " ") + "\n")
}

func escapeForFish(s string) string {
	s = strings.ReplaceAll(s, "'", "\\'")
	s = strings.ReplaceAll(s, "\\", "\\\\")
	return s
}
