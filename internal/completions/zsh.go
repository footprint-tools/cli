package completions

import (
	"fmt"
	"sort"
	"strings"
)

// GenerateZsh generates a zsh completion script
func GenerateZsh(commands []CommandInfo) string {
	bin := GetBinaryName()
	funcName := strings.ReplaceAll(bin, "-", "_")

	var b strings.Builder

	fmt.Fprintf(&b, `#compdef %s
# %s zsh completion script
# Generated by %s completions

_%s() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-v --version)'{-v,--version}'[Show version]' \
        '--no-color[Disable colored output]' \
        '--no-pager[Do not use pager]' \
        '--pager=[Use specified pager]:pager:' \
        '1: :_%s_commands' \
        '*::arg:->args'

    case $state in
        args)
            case $line[1] in
`, bin, bin, bin, funcName, funcName)

	// Generate case for each top-level command
	for _, cmd := range commands {
		if len(cmd.Path) != 2 {
			continue
		}

		fmt.Fprintf(&b, "                %s)\n", cmd.Name)
		fmt.Fprintf(&b, "                    _%s_%s\n", funcName, cmd.Name)
		b.WriteString("                    ;;\n")
	}

	fmt.Fprintf(&b, `            esac
            ;;
    esac
}

_%s_commands() {
    local -a commands
    commands=(
`, funcName)

	// Add all top-level commands with descriptions
	for _, cmd := range commands {
		if len(cmd.Path) != 2 {
			continue
		}
		summary := strings.ReplaceAll(cmd.Summary, "'", "'\\''")
		fmt.Fprintf(&b, "        '%s:%s'\n", cmd.Name, summary)
	}

	fmt.Fprintf(&b, `    )
    _describe -t commands '%s commands' commands
}

`, bin)

	// Generate function for each command with subcommands or flags
	for _, cmd := range commands {
		if len(cmd.Path) != 2 {
			continue
		}

		fmt.Fprintf(&b, "_%s_%s() {\n", funcName, cmd.Name)

		if len(cmd.Subcommands) > 0 {
			b.WriteString("    local -a subcommands\n")
			b.WriteString("    subcommands=(\n")

			// Find subcommand summaries
			for _, subcmdName := range cmd.Subcommands {
				subcmdPath := append(cmd.Path, subcmdName)
				if subcmd := FindCommand(commands, subcmdPath); subcmd != nil {
					summary := strings.ReplaceAll(subcmd.Summary, "'", "'\\''")
					fmt.Fprintf(&b, "        '%s:%s'\n", subcmdName, summary)
				}
			}

			b.WriteString("    )\n\n")
			b.WriteString("    _arguments -C \\\n")

			// Add flags for the group
			for _, f := range cmd.Flags {
				flagStr := formatZshFlag(f)
				if flagStr != "" {
					fmt.Fprintf(&b, "        %s \\\n", flagStr)
				}
			}

			b.WriteString("        '1: :->subcmd' \\\n")
			b.WriteString("        '*::arg:->args'\n\n")
			b.WriteString("    case $state in\n")
			b.WriteString("        subcmd)\n")
			b.WriteString("            _describe -t subcommands 'subcommands' subcommands\n")
			b.WriteString("            ;;\n")
			b.WriteString("    esac\n")
		} else {
			// Leaf command with just flags
			b.WriteString("    _arguments \\\n")
			for i, f := range cmd.Flags {
				flagStr := formatZshFlag(f)
				if flagStr != "" {
					if i < len(cmd.Flags)-1 {
						fmt.Fprintf(&b, "        %s \\\n", flagStr)
					} else {
						fmt.Fprintf(&b, "        %s\n", flagStr)
					}
				}
			}
			if len(cmd.Flags) == 0 {
				b.WriteString("        '*:file:_files'\n")
			}
		}

		b.WriteString("}\n\n")
	}

	// Register the completion function with compdef
	// This is needed when sourcing via eval (the #compdef line only works in fpath)
	fmt.Fprintf(&b, "compdef _%s %s\n", funcName, bin)

	return b.String()
}

func formatZshFlag(f FlagInfo) string {
	if len(f.Names) == 0 {
		return ""
	}

	desc := strings.ReplaceAll(f.Description, "'", "'\\''")
	desc = strings.ReplaceAll(desc, "[", "\\[")
	desc = strings.ReplaceAll(desc, "]", "\\]")

	// Sort names to get short flag first
	names := make([]string, len(f.Names))
	copy(names, f.Names)
	sort.Slice(names, func(i, j int) bool {
		return len(names[i]) < len(names[j])
	})

	if len(names) == 2 {
		// Both short and long form
		short := names[0]
		long := names[1]
		if f.HasValue {
			return fmt.Sprintf("'(%s %s)'%s'[%s]:value:'", short, long, fmt.Sprintf("{%s,%s}", short, long), desc)
		}
		return fmt.Sprintf("'(%s %s)'{%s,%s}'[%s]'", short, long, short, long, desc)
	}

	// Single flag
	if f.HasValue {
		return fmt.Sprintf("'%s=[%s]:value:'", names[0], desc)
	}
	return fmt.Sprintf("'%s[%s]'", names[0], desc)
}
