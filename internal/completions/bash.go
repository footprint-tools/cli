package completions

import (
	"fmt"
	"sort"
	"strings"
)

// GenerateBash generates a bash completion script
func GenerateBash(commands []CommandInfo) string {
	bin := GetBinaryName()
	funcName := strings.ReplaceAll(bin, "-", "_")

	var b strings.Builder

	b.WriteString(fmt.Sprintf(`# %s bash completion script
# Generated by %s completions

_%s_completions() {
    local cur prev words cword
    _init_completion || return

    local commands="`, bin, bin, funcName))

	// Get root command's subcommands
	var rootSubcmds []string
	for _, cmd := range commands {
		if len(cmd.Path) == 1 {
			rootSubcmds = cmd.Subcommands
			break
		}
	}
	sort.Strings(rootSubcmds)
	b.WriteString(strings.Join(rootSubcmds, " "))
	b.WriteString(`"

    # Handle subcommand completions
    case "${COMP_WORDS[1]}" in
`)

	// Generate case for each top-level command that has subcommands
	for _, cmd := range commands {
		if len(cmd.Path) != 2 {
			continue
		}
		if len(cmd.Subcommands) == 0 && len(cmd.Flags) == 0 {
			continue
		}

		b.WriteString(fmt.Sprintf("        %s)\n", cmd.Name))

		if len(cmd.Subcommands) > 0 {
			sort.Strings(cmd.Subcommands)
			b.WriteString("            if [[ $cword -eq 2 ]]; then\n")
			b.WriteString(fmt.Sprintf("                COMPREPLY=($(compgen -W \"%s\" -- \"$cur\"))\n", strings.Join(cmd.Subcommands, " ")))
			b.WriteString("                return\n")
			b.WriteString("            fi\n")
		}

		if len(cmd.Flags) > 0 {
			flagNames := make([]string, 0, len(cmd.Flags)*2)
			for _, f := range cmd.Flags {
				flagNames = append(flagNames, f.Names...)
			}
			sort.Strings(flagNames)
			b.WriteString(fmt.Sprintf("            COMPREPLY=($(compgen -W \"%s\" -- \"$cur\"))\n", strings.Join(flagNames, " ")))
		}

		b.WriteString("            ;;\n")
	}

	b.WriteString(`        *)
            ;;
    esac

    # Top-level commands
    if [[ $cword -eq 1 ]]; then
        COMPREPLY=($(compgen -W "$commands" -- "$cur"))
        return
    fi

    # Global flags
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "--help --version --no-color --no-pager" -- "$cur"))
        return
    fi
}

`)
	b.WriteString(fmt.Sprintf("complete -F _%s_completions %s\n", funcName, bin))

	return b.String()
}
